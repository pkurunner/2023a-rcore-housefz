1. 在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。 
- 需要回收的资源有哪些？ 
- 其他线程的 TaskControlBlock 可能在哪些位置被引用，分别是否需要回收，为什么？

    需要回收的资源：
        主线程退出时，会通过waittid收回其他之前已经退出线程的内核态用到的资源，比如内核栈等。同时，对于还在运行的资源，则既收回用户态资源，又收回内核态资源。同时，如果进程有对应父进程，则对应父进程会通过waitpid回收子进程剩余还没被回收的资源。具体如下：

        ①线程的用户态资源：
        用户态栈：每个线程都有自己的用户态栈，用于存储局部变量、函数调用记录等。
        系统调用和异常处理的跳板页：用于线程执行系统调用和处理异常时的中间数据和控制流程。

        ②线程的内核态资源：

        内核栈：每个线程在内核态执行时都有自己的栈，用于存放内核态函数的局部变量、函数调用记录等。
        线程控制块（TCB）：它包含线程的状态信息、调度信息、寄存器状态等。

        ③文件描述符和打开的文件：线程可能打开文件或者使用其他的I/O资源，这些资源需要被关闭和释放。

        ④同步原语的资源：如互斥锁、条件变量等，如果线程在退出时持有这些资源，应该适当释放以避免死锁或资源泄露。

        

    其他线程的TaskControlBlock 的可能引用位置，及是否需要回收：

        ①进程控制块：进程控制块中含有一个线程控制块列表，用于管理该进程下的所有线程。
        当主线程退出时，这些线程控制块需要被回收，因为它们是进程的一部分，整个进程的终止意味着所有线程的终止。
        
        ②调度器/线程管理器 (TaskManager)：调度器可能持有对线程控制块的引用以便进行线程调度。
        当主线程退出时，相关的线程控制块也应当被回收，因为这些线程将不再被调度或运行。



2. 对比以下两种 `Mutex.unlock` 的实现，二者有什么区别？这些区别可能会导致什么问题？

    ```
    1 impl Mutex for Mutex1 {
    2     fn unlock(&self) {
    3         let mut mutex_inner = self.inner.exclusive_access();
    4         assert!(mutex_inner.locked);
    5         mutex_inner.locked = false;
    6         if let Some(waking_task) = mutex_inner.wait_queue.pop_front() {
    7             add_task(waking_task);
    8         }
    9     }
    10 }
    11
    12 impl Mutex for Mutex2 {
    13     fn unlock(&self) {
    14         let mut mutex_inner = self.inner.exclusive_access();
    15         assert!(mutex_inner.locked);
    16         if let Some(waking_task) = mutex_inner.wait_queue.pop_front() {
    17             add_task(waking_task);
    18         } else {
    19             mutex_inner.locked = false;
    20         }
    21     }
    22 }
    ```
    
    Mutex1的实现：

    1. 先释放锁（设置 mutex_inner.locked = false）。
    2. 再检查等待队列 wait_queue是否有任务需要唤醒。
    
    Mutex2的实现：
    1. 先检查等待队列 wait_queue。
    2. 如果队列中有任务，先唤醒该任务。只有在队列为空时才释放锁（设置 mutex_inner.locked = false）。

    主要区别

    ①锁释放时机：Mutex1 在检查等待队列前就释放锁，而Mutex2 只在队列为空时才释放锁。

    ②等待任务的处理：Mutex1 优先释放锁，无论等待队列是否为空。Mutex2 只有优先唤醒等待	的任务，只在等待队列为空时才释放锁。
    
    潜在问题

    1. 竞争条件：Mutex1 的实现可能导致竞争条件。因为它先解锁，然后再处理等待队列。在解锁和唤醒等待任务的时间窗口内，其他线程可能会获取锁并改变状态，从而导致唤醒的任务看到不一致的状态、双重解锁等问题。
    2. 公平性问题：Mutex1允许新任务抢占锁，可能导致先进入等待队列的任务等待更长时间，公平性较差。而Mutex2 则较为公平，因为它优先处理等待队列中的任务，这意味着等待较长时间的任务更有可能被先处理。
    3. 死锁风险：如果 add_task 函数在某些情况下直接或间接尝试获取同一个锁，Mutex1 可能会导致死锁，因为它在锁仍然持有的状态下调用 `add_task`。
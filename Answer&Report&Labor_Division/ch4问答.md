1. **请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？**

   1. 页表项的组成：

      ![../_images/sv39-pte.png](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/sv39-pte.png)

      SV39的页表项一共有64位，其中 [63:54] 这10位为保留位，以便在未来的RISC-V架构扩展中引入新的功能； [53:10] 这 44 位是物理页号，用于指示物理内存中页的位置；最低的 8 位 [7:0] 则是标志位，用于指示页的一些属性和状态。

   2. 标志位及其作用：

      - V（Valid）位： 仅当V为1时，这个页表项是有效的，即它指向一个有效的物理页。
      - R（Read）位、W（Write）位和 X（Execute）位： 如果 R 位被设置，表示这个页可以被读取；W 位被设置，表示可以被写入；X 位被设置，表示可以执行其中的代码。
      - U（User）位： 如果设置，表示索引到这个页表项的对应虚拟页面可以被用户模式访问。如果未设置，只有更高权限级别（如 supervisor）可以访问。
      - A（Accessed）位 ：记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过。
      - D（Dirty）位：记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过。
      - G（Global）位： 如果设置，该页在所有地址空间中都是有效的，不受地址空间标识符（ASID）的影响。

2. - 缺页

     ​	缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。

      ①请问哪些异常可能是缺页导致的？

        1.指令页面错误：当处理器尝试从不存在于当前页表中的内存地址读取指令时，发生指令页面错误。

        2.加载页面错误：当处理器尝试从不存在于当前页表中的内存地址加载数据时，发生加载页面错误。

        3.存储页面错误：当处理器尝试写入不存在于当前页表中的内存地址时，发生存储页面错误。

     ​②发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。

     1.PC：程序计数器指向发生缺页异常时正在执行的指令的地址。

     2.故障地址寄存器：包含导致缺页异常的虚拟地址。这是处理缺页的关键信息，因为操作系统需要知道哪个虚拟地址的访问导致了异常。

     3.PSW：状态寄存器包含了异常发生时的处理器信息状态，如当前的权限级别、中断状态等。

     4.错误码寄存器：包含缺页的原因。

     缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。

     ③这样做有哪些好处？

     a.提高内存利用率。代码只有第一次被执行时才完成从磁盘的加载操作，这意味着只有会被使用的代码才会占用物理内存空间，提高了内存的利用效率。

     b.减少启动时间。程序启动时不必加载全部的代码和数据，减少了启动时的磁盘读取时间。

     c.支持更大的地址空间。由于实际使用的内存量小于或等于物理内存大小，操作系统可以允许程序拥有比实际物理内存更大的虚拟内存空间。

     d.优化I/O操作：只有在需要时才从磁盘加载数据，减少了不必要的I/O操作。这对于I/O密集型的系统来说尤其重要.

     e.支持按需分页：允许操作系统根据程序的实际需求动态地分配内存。这样做不仅减少了物理内存的使用，还可以避免不必要的页面换入换出操作。

     其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。

      ④处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？

     标准页的大小：4KB

     SV39页表项的大小：8B

     页表层级：三级页表

     总共需要的页数：10GB/4KB=5*2^11页

     页表项占用：5 * 2^11 *8B = 20MB

     由于 SV39 是三级页表，我们还需考虑上级页表项占用的内存。但上级页表项的数量远少于最底层页表项的数量，它们的内存占用相对底层页表项，在数量级意义上可以忽略不计。所以数量级是10^1MB。

      ⑤请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。

     实现Lazy策略：

     1.内存映射时不立即分配物理页面：

     当进程通过 `mmap` 或类似机制申请内存空间时，操作系统只记录映射的虚拟地址范围和磁盘上的位置信息（如果有），而不立即为这些虚拟地址分配对应的物理内存页面。

     2.页表项初始化：

     在页表中为这些虚拟地址创建页表项，但是将这些页表项标记为无效（即未分配物理页面）。这样，当实际访问这些地址时，由于页表项无效，将触发缺页异常。

     缺页处理：

     ​1.异常捕获：

     当进程首次访问某个虚拟地址时，由于相应的页表项未被映射到有效的物理内存，MMU 会触发缺页中断，并将控制权交给操作系统。

     2.确定缺页原因：

     操作系统通过缺页异常处理程序中检查异常的原因。它将查看触发异常的虚拟地址，以确定这是合法的延迟映射请求，而不是非法内存访问。

     3.分配物理内存：

     一旦确认需要加载页面，操作系统会为该虚拟地址分配一个物理内存页面。若是对文件的映射，还需从磁盘读取相应数据到分配的物理页面。

     4.更新页表：

      将虚拟地址映射到新分配的物理内存页面，并将页表项标记为有效。

     5.重新执行指令：

     完成物理页面分配和页表更新后，操作系统将控制权返回给应用程序，使得导致缺页的指令能够重新执行并成功访问内存。

     缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。

      ⑥此时页面失效如何表现在页表项(PTE)上？

     1.有效位（V位）会被清零。

     2.PPN可能会变化，由于页面不再驻留在物理内存中，PPN可能会被清空或修改，不再指向原来的物理内存地址。

      3.访问权限的变化：页面被换出时，页表项中的访问权限（如可读、可写、可执行）可能会被修改或清除，以防止程序在页面不在物理内存时访问该页。

3. 双页表与单页表

   为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 [KPTI](https://en.wikipedia.org/wiki/Kernel_page-table_isolation) )

   - 在单页表情况下，如何更换页表？

     ​	①进入内核态：当程序执行系统调用或触发中断时，CPU 会切换到内核态。

     ​	②使用相同页表：用户空间和内核空间共用一张页表，页表中既包含用户空间的映射，也包含内核空间的映射，但内核空间的地址仅在内核态可访问。

   - 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）

     ​	①访问权限位：页表项中有用于控制访问权限的位：可读（R）、可写（W）和可执行（X）。操作系统设置这些位来控制对应页面的访问权限。

     ​	②用户/内核模式区分：页表项中有一个区分用户模式和内核模式的位（ U）。当此位设置为用户模式时，只有在用户态执行时才能访问对应的页面。相反，如果这个位被设置为内核模式，则只有在内核态执行时才能访问该页面。

   - 单页表有何优势？（回答合理即可）

     ​	①上下文切换效率高：在进行用户态和内核态切换时，由于使用同一张页表，不需要切换	页表，提高了上下文切换效率。

     ​	②内存开销较低：单页表设计只需要维护一套页表结构，在内存中占用更少的空间。

     ​	③系统调用和中断处理更快：由于不需要切换页表，系统调用和中断处理会更快。这对需要频繁进入内核态的操作（如I/O密集型应用）来说尤其有利。

     ​	④简化内存管理：在内核中，内存管理相关的数据结构和算法可以更直接地操作单一页表，无需担心同步两套页表的问题。

   - 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

     ​	何时更换：

     ​	①从用户态切换到内核态：系统调用或发生中断/异常时，CPU 从用户态切换到内核态，操作系统也从用户态页表切换到内核态页表，该页表包含了完整的内核空间映射和有限且必要的用户空间映射。

     ​	②从内核态切换到用户态：系统调用或发生中断/异常处理完成后，CPU 从用户态切换到内核态，操作系统也切换回用户态页表，该页表只包含用户空间的映射。

     ​	我的选择：

     ​	①在进程切换时：每个进程在操作系统中有自己的页表，该页表定义了进程的虚拟地址空间。在切换到新进程时，必须加载该进程的页表，以便它可以访问自己的虚拟地址空间。

      ②创建新进程时：当创建新进程（如通过 fork 或 exec 系统调用）时，为新进程创建一个新的页表，并在开始执行该进		程时切换到这个页表。

      ③结束进程时：释放该进程的页表，并在切换到下一个执行的进程时加载该进程的页表。